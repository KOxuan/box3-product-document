import { ssrRenderAttrs } from "vue/server-renderer";
import { useSSRContext } from "vue";
import { _ as _export_sfc } from "./plugin-vue_export-helper.1tPrXgE0.js";
const __pageData = JSON.parse('{"title":"项目架构解惑：为何TypeScript项目拥有众多配置文件","description":"","frontmatter":{},"headers":[],"relativePath":"guide/two/qa.md","filePath":"guide/two/qa.md","lastUpdated":1733301572000}');
const _sfc_main = { name: "guide/two/qa.md" };
function _sfc_ssrRender(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  _push(`<div${ssrRenderAttrs(_attrs)}><h1 id="项目架构解惑-为何typescript项目拥有众多配置文件" tabindex="-1">项目架构解惑：为何TypeScript项目拥有众多配置文件 <a class="header-anchor" href="#项目架构解惑-为何typescript项目拥有众多配置文件" aria-label="Permalink to &quot;项目架构解惑：为何TypeScript项目拥有众多配置文件&quot;">​</a></h1><p>初次接触TypeScript项目的创作者可能会对项目中的众多配置文件感到困惑，例如<code>package.json</code>、<code>dao3.config.json</code>、<code>tsconfig.json</code>以及<code>webpack.config.js</code>等。</p><div class="info custom-block"><p class="custom-block-title">为什么服务端和客户端各有一套？</p><ul><li><strong>环境差异</strong>：服务端和客户端的运行环境不同，因此它们的配置需求也不同。例如，服务端需要在神岛Node.js环境下运行，而客户端则需要在浏览器中运行。</li><li><strong>功能需求</strong>：服务端和客户端的功能需求也不同。服务端通常负责处理业务逻辑和数据存储，而客户端则负责玩家界面和交互。这些不同的功能需求导致它们需要不同的依赖项和配置选项。</li><li><strong>代码组织</strong>：为了保持代码的清晰和可维护性，将服务端和客户端的代码和配置文件分开是一个常见的做法。这有助于创作者更好地理解项目的结构，并更容易地进行代码修改和调试。</li></ul></div><div class="info custom-block"><p class="custom-block-title">💡给初次接触TypeScript项目的创作者一些说明</p><p>其实，神岛的Arena编辑器背后也采用了Node.js项目架构，但为了简化创作者的操作，他们隐藏了复杂的配置。创作者只需编写js脚本，使得初学者感觉非常友好。</p><p>然而，当面对复杂的项目时，这种简化可能会显得力不从心，甚至让创作者感到特别难用。相比之下，ArenaPro则将这些配置全部公开，让创作者能够自定义配置，这种灵活性更适合中大型项目的需求。</p><hr><p>在软件开发的世界里，许多优秀的项目都包含了大量的配置文件和依赖项。这不仅是Node.js项目的特点，也是许多其他编程语言和框架的常态。这些配置文件和依赖项是构建复杂、功能丰富的应用程序所不可或缺的。</p><p>想象一下，如果你正在构建一个大型的电子商务平台，你需要处理创作者认证、数据库交互、支付处理、商品搜索和推荐等多种功能。每个功能都可能依赖于一个或多个外部库或框架，而这些库和框架又可能包含自己的依赖项。因此，项目中的配置文件和依赖项数量自然会逐渐增多。</p><p>但请不必被这些看似复杂的配置所吓倒。随着时间的推移和经验的积累，你会逐渐熟悉这些配置文件的作用，并学会如何有效地管理它们。你会发现，使用如<code>npm</code>、<code>yarn</code>和<code>Webpack</code>等工具，可以极大地简化依赖项的管理和项目的构建过程。这些工具不仅提高了开发效率，还确保了项目的稳定性和可维护性。</p></div><h2 id="package-json" tabindex="-1">package.json <a class="header-anchor" href="#package-json" aria-label="Permalink to &quot;package.json&quot;">​</a></h2><ul><li><strong>作用</strong>：作为Node.js项目的核心配置文件，<code>package.json</code>用于管理项目的依赖、脚本、版本等信息。</li><li><strong>服务端与客户端差异</strong>：无，服务端和客户端共用一套。</li></ul><h2 id="package-lock-json" tabindex="-1">package-lock.json <a class="header-anchor" href="#package-lock-json" aria-label="Permalink to &quot;package-lock.json&quot;">​</a></h2><ul><li><strong>作用</strong>：<code>package-lock.json</code> 是一个由 <code>npm</code> 自动生成的文件，其主要功能是确保项目中所安装的依赖项版本的一致性。当你使用 <code>npm install</code> 命令来安装项目所需的依赖时，<code>npm</code> 会根据 <code>package.json</code> 文件中列出的依赖项及其版本范围，生成一个 <code>package-lock.json</code> 文件。这个文件中详细记录了每个依赖项的确切版本号，以及它们之间的依赖关系树。</li><li><strong>服务端与客户端差异</strong>：无，服务端和客户端共用一套。</li></ul><h2 id="node-modules" tabindex="-1">node_modules <a class="header-anchor" href="#node-modules" aria-label="Permalink to &quot;node_modules&quot;">​</a></h2><ul><li><strong>作用</strong>：在Node.js项目中，<code>node_modules</code> 文件夹是一个非常重要的部分，它包含了项目所需的所有npm包（即依赖项）。这些包可能是项目直接依赖的，也可能是这些直接依赖项的依赖项（也称为子依赖项或嵌套依赖项）。<code>node_modules</code> 文件夹通常位于项目的根目录下，与 <code>package.json</code> 和 <code>package-lock.json</code> 文件一起构成项目的依赖管理系统。</li><li><strong>服务端与客户端差异</strong>：无，服务端和客户端共用一套。</li></ul><h2 id="dao3-config-json" tabindex="-1">dao3.config.json <a class="header-anchor" href="#dao3-config-json" aria-label="Permalink to &quot;dao3.config.json&quot;">​</a></h2><ul><li><strong>作用</strong>：<code>dao3.config.json</code>是一个神岛项目的自定义配置文件，它的作用是配置项目与神岛地图之间的关系。</li><li><strong>服务端与客户端差异</strong>：无，服务端和客户端共用一套。</li></ul><h2 id="tsconfig-json" tabindex="-1">tsconfig.json <a class="header-anchor" href="#tsconfig-json" aria-label="Permalink to &quot;tsconfig.json&quot;">​</a></h2><ul><li><strong>作用</strong>：作为TypeScript项目的核心配置文件，<code>tsconfig.json</code>用于定义TypeScript编译器的行为和选项。</li><li><strong>服务端与客户端差异</strong>：服务端和客户端的<code>tsconfig.json</code>文件包含不同的编译选项和目标设置。例如，服务端需要针对神岛的Node.js环境进行编译，而客户端则需要针对浏览器环境进行编译。此外，它们还可能包含不同的文件包含/排除规则，以确保只编译必要的文件。</li></ul><h2 id="webpack-config-js" tabindex="-1">webpack.config.js <a class="header-anchor" href="#webpack-config-js" aria-label="Permalink to &quot;webpack.config.js&quot;">​</a></h2><ul><li><strong>作用</strong>：作为Webpack打包工具的配置文件，<code>webpack.config.js</code>用于定义项目的打包策略、加载器、插件等。</li><li><strong>服务端与客户端差异</strong>：服务端和客户端的<code>webpack.config.js</code>文件包含不同的配置选项，以适应不同的打包需求。例如，服务端脚本打包规范是<code>CommonJS</code>，客户端脚本打包规范是<code>ES5</code>。此外，它们还包含不同的入口文件和输出配置。</li></ul></div>`);
}
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("guide/two/qa.md");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};
const qa = /* @__PURE__ */ _export_sfc(_sfc_main, [["ssrRender", _sfc_ssrRender]]);
export {
  __pageData,
  qa as default
};
