import { ssrRenderAttrs, ssrRenderAttr, ssrRenderStyle } from "vue/server-renderer";
import { useSSRContext } from "vue";
import { _ as _export_sfc } from "./plugin-vue_export-helper.1tPrXgE0.js";
const _imports_0 = "/arenapro/QQ20241128-233644.png";
const _imports_1 = "/arenapro/QQ20241128-233716.png";
const _imports_2 = "/arenapro/QQ20241128-233914.png";
const _imports_3 = "/arenapro/QQ20241210-141043.png";
const _imports_4 = "/arenapro/6CD4C58B97A169272B29BB0E4A7FB731.png";
const __pageData = JSON.parse('{"title":"热模块替换","description":"","frontmatter":{},"headers":[],"relativePath":"guide/four/hmr.md","filePath":"guide/four/hmr.md","lastUpdated":1733811620000}');
const _sfc_main = { name: "guide/four/hmr.md" };
function _sfc_ssrRender(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  _push(`<div${ssrRenderAttrs(_attrs)}><h1 id="热模块替换" tabindex="-1">热模块替换 <a class="header-anchor" href="#热模块替换" aria-label="Permalink to &quot;热模块替换&quot;">​</a></h1><p><img src="https://static.codemao.cn/pickduck/HJBNk__g1x.gif?hash=Fq9hwMXyh-2yGkZY1t42TXPsw57i" alt=""></p><p>本指南旨在帮助你使用VSCode进行神岛项目的调试，特别是如何利用模块热替换（HMR）编译功能来提升调试效率。通过HMR，你可以在编辑代码时实现自动编译，并即时将更新上传至神岛编辑器，从而大大加速调试和测试流程。</p><h2 id="如何操作hmr服务器" tabindex="-1">如何操作HMR服务器 <a class="header-anchor" href="#如何操作hmr服务器" aria-label="Permalink to &quot;如何操作HMR服务器&quot;">​</a></h2><h3 id="开启服务器" tabindex="-1">开启服务器 <a class="header-anchor" href="#开启服务器" aria-label="Permalink to &quot;开启服务器&quot;">​</a></h3><p>在VSCode的左下角，你可以找到HMR服务器的状态指示。若服务器未开启，请点击<code>启动HMR服务器</code>按钮。系统将自动读取<code>webpack</code>配置并启动服务器。</p><ul><li><strong>图标颜色</strong>：橙色（表示服务器未启动）</li></ul><p><img${ssrRenderAttr("src", _imports_0)} alt="HMR服务器启动图标"></p><p>开启后，HMR服务器将监听文件修改，并自动进行编译和上传。</p><h3 id="重启-关闭服务器" tabindex="-1">重启/关闭服务器 <a class="header-anchor" href="#重启-关闭服务器" aria-label="Permalink to &quot;重启/关闭服务器&quot;">​</a></h3><p>若已启用服务器，你可以通过点击相同位置的按钮来关闭或重启服务器。</p><ul><li><strong>图标颜色</strong>：绿色（表示服务器已启动并正常工作）</li></ul><p><img${ssrRenderAttr("src", _imports_1)} alt="HMR服务器重启/关闭图标"></p><h3 id="服务器异常处理" tabindex="-1">服务器异常处理 <a class="header-anchor" href="#服务器异常处理" aria-label="Permalink to &quot;服务器异常处理&quot;">​</a></h3><p>有时，HMR服务器可能会因各种原因停止运行。此时，图标将变为红色，并显示相应的错误信息。</p><ul><li><strong>图标颜色</strong>：红色（表示服务器异常停止）</li></ul><p><img${ssrRenderAttr("src", _imports_2)} alt="HMR服务器异常图标"></p><h2 id="代码分离-多入口文件" tabindex="-1">代码分离（多入口文件） <a class="header-anchor" href="#代码分离-多入口文件" aria-label="Permalink to &quot;代码分离（多入口文件）&quot;">​</a></h2><p>代码分离是 Webpack 中最引人注目的特性之一。它能够将代码分离到不同的 bundle 中，从而允许我们按需加载或并行加载这些文件。这一特性在优化前端性能方面发挥着至关重要的作用，因为它可以帮助我们获取更小的 bundle、控制资源加载优先级，并在使用合理的情况下极大减小加载时间。</p><p>然而，值得注意的是，代码分离也存在一些潜在的隐患：</p><ul><li><strong>重复模块问题</strong>：如果入口 chunk 之间包含一些重复的模块，这些重复模块可能会被引入到各个 bundle 中，从而导致不必要的代码冗余。</li></ul><h3 id="配置入口文件" tabindex="-1">配置入口文件 <a class="header-anchor" href="#配置入口文件" aria-label="Permalink to &quot;配置入口文件&quot;">​</a></h3><p>需要在 <code>outputAndUpdate</code> 属性下设置一个对象，该对象将包含我们的入口文件配置。</p><div class="language-json vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">{</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#005CC5", "--shiki-dark": "#79B8FF" })}">  &quot;outputAndUpdate&quot;</span><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">: [</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    {</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#005CC5", "--shiki-dark": "#79B8FF" })}">        &quot;name&quot;</span><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">: </span><span style="${ssrRenderStyle({ "--shiki-light": "#032F62", "--shiki-dark": "#9ECBFF" })}">&quot;bundle.js&quot;</span><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">, </span><span style="${ssrRenderStyle({ "--shiki-light": "#6A737D", "--shiki-dark": "#6A737D" })}">// 打包后bundle文件名</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#005CC5", "--shiki-dark": "#79B8FF" })}">        &quot;serverEntry&quot;</span><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">: </span><span style="${ssrRenderStyle({ "--shiki-light": "#032F62", "--shiki-dark": "#9ECBFF" })}">&quot;src/App.ts&quot;</span><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">,  </span><span style="${ssrRenderStyle({ "--shiki-light": "#6A737D", "--shiki-dark": "#6A737D" })}">// 服务端入口文件路径</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#005CC5", "--shiki-dark": "#79B8FF" })}">        &quot;clientEntry&quot;</span><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">: </span><span style="${ssrRenderStyle({ "--shiki-light": "#032F62", "--shiki-dark": "#9ECBFF" })}">&quot;src/clientApp.ts&quot;</span><span style="${ssrRenderStyle({ "--shiki-light": "#6A737D", "--shiki-dark": "#6A737D" })}">  // 客户端入口文件路径</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    },</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">  ]</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>在这个配置对象中，我们可以定义多个入口文件，Webpack 会根据这些入口文件生成不同的 bundle。以下是一个示例配置：</p><p><img${ssrRenderAttr("src", _imports_3)} alt=""></p><p>在上面的配置中，所有在 <code>outputAndUpdate</code> 对象中定义的入口文件都会被 Webpack 监听，并打包成不同的 bundle，然后上传至地图中。</p><p><img${ssrRenderAttr("src", _imports_4)} alt=""></p><p>需要注意的是：</p><ul><li>在完整编译过程中，Webpack 仅会读取 <code>outputAndUpdate</code> 对象中的<code>第一项</code>配置作为主入口。</li><li>在进行热模块替换（HMR）编译时，Webpack 会监听 <code>outputAndUpdate</code> 对象数组中的所有配置，以便在开发过程中实现模块的热替换。</li></ul><h2 id="注意事项" tabindex="-1">注意事项 <a class="header-anchor" href="#注意事项" aria-label="Permalink to &quot;注意事项&quot;">​</a></h2><h3 id="监听范围与方式" tabindex="-1">监听范围与方式 <a class="header-anchor" href="#监听范围与方式" aria-label="Permalink to &quot;监听范围与方式&quot;">​</a></h3><ul><li>HMR服务器仅监听<code>server</code>和<code>client</code>目录下的入口文件。一旦这些文件发生变动，服务器将立即触发编译流程。</li><li>非监听文件（如<code>node_modules</code>、<code>dist</code>、<code>webpack.config.js</code>等）的修改不会触发编译。</li></ul><h3 id="配置文件管理" tabindex="-1">配置文件管理 <a class="header-anchor" href="#配置文件管理" aria-label="Permalink to &quot;配置文件管理&quot;">​</a></h3><ul><li>在启动HMR服务器之前，请确保所有相关配置文件（如<code>webpack.config.js</code>、<code>dao3.config.json</code>、<code>tsconfig.json</code>）已正确配置。</li><li>若在HMR服务器运行后修改配置文件，你需要重启服务器才能使更改生效。</li></ul><h3 id="别名差异" tabindex="-1">别名差异 <a class="header-anchor" href="#别名差异" aria-label="Permalink to &quot;别名差异&quot;">​</a></h3><ul><li>在完整编译流程中，项目文件通常被编译成多个小模块的JavaScript文件，并放置在<code>dist</code>文件夹中。此时，文件路径将基于<code>tsconfig.js</code>中的<code>rootDir</code>属性。</li><li>在HMR编译流程中，文件将从当前所在的<code>server</code>或<code>client</code>文件夹中读取，而不是从<code>dist</code>文件夹中读取。</li></ul><h3 id="神岛账户配置" tabindex="-1">神岛账户配置 <a class="header-anchor" href="#神岛账户配置" aria-label="Permalink to &quot;神岛账户配置&quot;">​</a></h3><ul><li>在开启HMR服务器之前，请确保你已登录神岛账号并配置了地图。某些功能（如数据上传）可能依赖于这些配置。</li><li>若未登录或未配置，可能会影响到数据的上传和同步。</li></ul><h3 id="多工作区支持" tabindex="-1">多工作区支持 <a class="header-anchor" href="#多工作区支持" aria-label="Permalink to &quot;多工作区支持&quot;">​</a></h3><ul><li>在多工作区环境中，你可以在各自工作区分别开启HMR服务器。系统将自动判断当前工作区，并加载相应的配置文件。</li></ul></div>`);
}
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("guide/four/hmr.md");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};
const hmr = /* @__PURE__ */ _export_sfc(_sfc_main, [["ssrRender", _sfc_ssrRender]]);
export {
  __pageData,
  hmr as default
};
